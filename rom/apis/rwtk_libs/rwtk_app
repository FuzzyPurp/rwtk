-----------------------------------------------------------------------------
-- Redworks Toolkit
-- Author: MewK
--
-- This program is released under the MIT License (MIT).
-----------------------------------------------------------------------------

-- Using:
os.loadAPI('/rom/apis/rwtk_libs/rwtk_core')

-----------------------------------------------------------------------------
-- Component class
-----------------------------------------------------------------------------

component = rwtk_core.class(function(_self, properties)
	local _width, _height = term.getSize()
	
	-- Default properties
	_self.border = true
	--_self.focusable = false
	_self.focused = false
	_self.height = _height
	_self.padding = 1
	_self.visible = true
	_self.width = _width
	_self.x = 1
	_self.y = 1
	
	-- User properties
	if properties then
		-- Copy properties
		for key, value in pairs(properties) do
			_self[key] = value
		end
	
		-- Check padding
		if not _self.border then
			_self.padding = 0
		end
		
		if not _self.x then
			_self.x = 1
		end
		if not _self.y then
			_self.y = 1
		end
		if not _self.witdh then
			_self.witdh = _witdh
		end
		if not _self.height then
			_self.height = _height
		end
	end
end)

-- Base functions

function component:innerDimensions(outerX, outerY, outerWidth, outerHeight)
	outerX = outerX + self.x + self.padding - 1
	outerY = outerY + self.y + self.padding - 1
	outerWidth = self.width - 2 * self.padding
	outerHeight = self.height - 2 * self.padding
	return outerX, outerY, outerWidth, outerHeight
end

function component:onDrawInternal(outerX, outerY, outerWidth, outerHeight, keepBackground)
	local innerX, innerY, innerWidth, innerHeight = self:innerDimensions(outerX, outerY, outerWidth, outerHeight)

	-- Clear
	if not keepBackground then
		rwtk_draw.fillRectangle(innerX, innerY, self.width, self.height, ' ')
	end
	
	-- Draw frame
	if self.border then
		rwtk_draw.drawRectangle(outerX + self.x - 1, outerY + self.y - 1, self.width, self.height)
	end
end

function component:onKeyInternal(keyCode)
	-- do something
end

-----------------------------------------------------------------------------
-- Application class
-----------------------------------------------------------------------------

application = rwtk_core.class(function(_self, properties)
	local _width, _height = term.getSize()

	-- Default properties
	_self.cursorX = 1
	_self.cursorY = 1
	_self.focusIndex = 0
	_self.height = _height
	_self.frames = {}
	_self.running = false
	_self.showCursor = false
	_self.width = _width
	_self.x = 1
	_self.y = 1
	
	-- User properties
	if properties then
		for key, value in pairs(properties) do
			_self[key] = value
		end
		
		if not _self.x then
			_self.x = 1
		end
		if not _self.y then
			_self.y = 1
		end
		if not _self.width then
			_self.width = _width
		end
		if not _self.height then
			_self.height = _height
		end
	end
end)

function application:getFrame(name)
	for index, frame in ipairs(self.frames) do
		if frame.name == name then
			return frame, index 
		end
	end
	return nil, nil
end

function application:getActiveFrame()
	if self.focusIndex > 0 then
		return self.frames[self.focusIndex]
	end
	return false
end

function application:removeFrame(name)
	-- Get frame
	local frame, index = self:getFrame(name)
	
	-- Remove frame
	if index then
		table.remove(self.frames, index)
		-- Change focus
		if index == self.focusIndex then
			self.focusIndex = self.focusIndex - 1
		end
	end
end
	
function application:addFrame(name, frame)
	-- Remove frame if exists
	self:removeFrame(name)
	
	-- Add frame
	frame.application = self
	if frame.components then
		for index, component in ipairs(frame.components) do
			component.application = self
		end
	end
	frame.name = name
	table.insert(self.frames, frame)
end

function application:focusFrame(name)
	-- Get frame
	local frame, index = self:getFrame(name)
	if frame then
		-- DeFocus old frame
		if self.focusIndex > 0 then
			self.frames[self.focusIndex].focused = false
		end
		
		-- Focus new frame
		frame.focused = true;
		self.focusIndex = index
	end
end

function application:callEvent(eventHandler, ...)
	local function _callEvent(frame, name, ...)
		if frame and frame[name] then
			return frame[name](frame, ...)
		end
	end
	
	local function _drawComponentsRecursive(components, innerX, innerY, innerWidth, innerHeight)
		local stopEvent
		for index, component in ipairs(components) do
			if component.visible then
				local innerComponentX, innerComponentY, innerComponentWidth, innerComponentHeight = component:innerDimensions(innerX, innerY, innerWidth, innerHeight)
				rwtk_draw.fillRectangle(innerComponentX, innerComponentY, innerComponentWidth, innerComponentHeight, ' ')
				term.setCursorPos(innerComponentX, innerComponentY)
				stopEvent = _callEvent(component, 'onDraw', innerComponentX, innerComponentY, innerComponentWidth, innerComponentHeight)
				if not stopEvent then
					if component.components then
						cursorX, cursorY = _drawComponentsRecursive(component.components, innerComponentX, innerComponentY, innerComponentWidth, innerComponentHeight)
						if cursorX and cursorY then
							_cursorX, _cursorY = cursorX, cursorY
						end
					end
					term.setCursorPos(innerX, innerY)
					_callEvent(component, 'onDrawInternal', innerX, innerY, innerWidth, innerHeight)
				end
			end
		end
	end

	local stopEvent
	
	-- Call application handler
	if self[eventHandler] then 
		stopEvent = self[eventHandler](self, ...) 
	end

	-- Call frame & component handler
	if not stopEvent then
		-- Recursive (all visible frames, all visible components
		if eventHandler == 'onDraw' then
			term.clear()
			term.setCursorPos(1, 1)
			term.setCursorBlink(false)
			if self.frames then
				_drawComponentsRecursive(self.frames, self.x, self.y, self.width, self.height)
			end
			if self.showCursor then
				term.setCursorBlink(self.showCursor)
			end
			if self.cursorX and self.cursorY then
				term.setCursorPos(self.cursorX, self.cursorY)
			end
			
		-- Active chain
		else
			-- Active frame
			local activeFrame = self:getActiveFrame()
			stopEvent = _callEvent(activeFrame, eventHandler, ...)
			if not stopEvent then
				stopEvent = _callEvent(activeFrame, eventHandler..'Internal', ...)
				
				-- Active component
				local activeComponent = activeFrame:getActiveComponent()
				if not stopEvent and activeComponent then
					stopEvent = _callEvent(activeComponent, eventHandler, ...)
					if not stopEvent then
						stopEvent = _callEvent(activeComponent, eventHandler..'Internal', ...)
					end
				end
			end
		end
	end
	-- print(cursorX..'x'..cursorY)
	-- read()
	if _cursorX and _cursorY then
		term.setCursorPos(cursorX, cursorY)
	end
end

function application:start()
	local handlerNames = {
		alarm = 'onAlarm',
		char = 'onChar',
		disk = 'onDisk',
		disk_eject = 'onDiskEject',
		key = 'onKey',
		rednet_message = 'onRednet',
		redstone = 'onRedstone',
		timer = 'onTimer'
	}
	
	self.running = true
	
	-- onStart
	self:callEvent('onStart')
	
	-- Draw screen
	self:callEvent('onDraw')
	
	while self.running do
		-- Pull event
		local event, param1, param2, param3 = os.pullEvent()
		
		-- Handle event
		self:callEvent('onEvent', event, param1, param2, param3)
		if handlerNames[event] then
			self:callEvent(handlerNames[event], param1, param2, param3)
		end
		
		-- Draw screen
		self:callEvent('onDraw')
	end
	
	-- onStop
	self:callEvent('onStop')
	
	-- Clear screen
	term.clear()
	term.setCursorPos(1, 1)
end

function application:stop()
	self.running = false
end

-- Factory function
function create(properties)
	return application(properties)
end